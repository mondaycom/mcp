import { z } from 'zod';
import { ToolInputType, ToolOutputType, ToolType } from '../tool';
import { BaseMondayApiTool } from './base-monday-api-tool';
import { getUpdates } from '../../monday-graphql/queries.graphql'; // Import the query

// Simulated generated types (Ideally, these would come from a .d.ts file generated by GraphQL codegen)
interface UpdateCreator {
  id: string;
  name: string;
}

interface Update {
  id: string;
  text_body?: string | null;
  created_at: string;
  creator?: UpdateCreator | null;
  item_id?: string | null;
  // Add other fields from the Update type as needed by the query
}

interface GetUpdatesQueryData {
  updates?: Update[] | null;
}

// This represents the actual structure returned by this.mondayApi.request
interface MondayApiResponse<T> {
  data?: T | null;
  errors?: Array<{ message: string; [key: string]: any }> | null;
}

// Simulated generated query variables type
interface GetUpdatesQueryVariables {
  ids?: string[];
  limit?: number;
  page?: number;
  from_date?: string;
  to_date?: string;
}

export const getUpdatesToolSchema = {
  ids: z.array(z.preprocess(val => String(val), z.string())).optional().describe("A list of updates unique identifiers (numbers will be automatically converted to strings)."),
  limit: z.number().int().optional().default(25).describe("Number of updates to get, the default is 25."),
  page: z.number().int().optional().default(1).describe("Page number to get, starting at 1."),
  from_date: z.string().optional().describe("Optional. The start date for filtering updates (YYYY-MM-DD or YYYY-MM-DDTHH:mm). Leave empty if not filtering by start date."),
  to_date: z.string().optional().describe("Optional. The end date for filtering updates (YYYY-MM-DD or YYYY-MM-DDTHH:mm). Leave empty if not filtering by end date."),
};

export type GetUpdatesToolInput = typeof getUpdatesToolSchema;

// Changed BaseMondayApiTool generic for Output to never
export class GetUpdatesTool extends BaseMondayApiTool<GetUpdatesToolInput, never> {
  name = 'get_updates';
  type = ToolType.QUERY;

  getDescription(): string {
    return 'Get a collection of updates, optionally filtered by date range or updates ids, with pagination.';
  }

  getInputSchema(): GetUpdatesToolInput {
    return getUpdatesToolSchema;
  }

  // Changed return type to Promise<ToolOutputType<never>>
  async execute(input: ToolInputType<GetUpdatesToolInput>): Promise<ToolOutputType<never>> {
    const variables: GetUpdatesQueryVariables = {
      ids: input.ids?.map(id => String(id)),
      limit: input.limit,
      page: input.page,
      from_date: input.from_date,
      to_date: input.to_date,
    };

    const definedVariables: GetUpdatesQueryVariables = Object.fromEntries(
      Object.entries(variables).filter(([, value]) => value !== undefined)
    ) as GetUpdatesQueryVariables;

    const res = await this.mondayApi.request<MondayApiResponse<GetUpdatesQueryData>>(getUpdates, definedVariables);

    if (res.errors && res.errors.length > 0) {
      return {
        content: `Error fetching updates: ${res.errors.map(e => e.message).join('; ')}`,
      };
    }
    
    if (res.data?.updates && res.data.updates.length > 0) {
      const updatesSummary = res.data.updates.map(update => 
        `Update ID: ${update.id}, Created At: ${update.created_at}, Item ID: ${update.item_id}, Creator: ${update.creator?.name || 'N/A'}\nBody: ${update.text_body || '(No text body)'}`
      ).join('\n---\n');
      return {
        content: `Successfully fetched ${res.data.updates.length} updates:\n${updatesSummary}`,
      };
    } else if (res.data?.updates && res.data.updates.length === 0) {
      return {
        content: 'No updates found matching the criteria.',
      };
    } else {
       return {
        content: 'Failed to fetch updates. The response data was not in the expected format or contained no updates data. Full response: ' + JSON.stringify(res),
      };
    }
  }
} 